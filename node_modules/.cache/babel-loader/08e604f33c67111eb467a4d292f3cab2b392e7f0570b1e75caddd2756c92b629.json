{"ast":null,"code":"/**\n * Local Storage Service for managing user favorites\n * Supports both authenticated and unauthenticated users\n * Uses timestamps for conflict resolution during sync\n */\n\nconst FAVORITES_KEY = 'glg_favorites';\nexport const localStorageService = {\n  /**\n   * Get favorites from localStorage\n   * @returns {Object} { favorites: number[], lastModified: string }\n   */\n  getFavorites() {\n    try {\n      const stored = localStorage.getItem(FAVORITES_KEY);\n      if (!stored) {\n        return {\n          favorites: [],\n          lastModified: null\n        };\n      }\n      const parsed = JSON.parse(stored);\n\n      // Handle legacy format (just array of favorites)\n      if (Array.isArray(parsed)) {\n        return {\n          favorites: parsed,\n          lastModified: null\n        };\n      }\n\n      // New format with timestamp\n      return {\n        favorites: parsed.favorites || [],\n        lastModified: parsed.lastModified || null\n      };\n    } catch (error) {\n      console.error('Error reading favorites from localStorage:', error);\n      return {\n        favorites: [],\n        lastModified: null\n      };\n    }\n  },\n  /**\n   * Set favorites in localStorage with current timestamp\n   * @param {number[]} favorites - Array of game IDs\n   */\n  setFavorites(favorites) {\n    try {\n      const data = {\n        favorites: favorites || [],\n        lastModified: new Date().toISOString()\n      };\n      localStorage.setItem(FAVORITES_KEY, JSON.stringify(data));\n      return data.lastModified;\n    } catch (error) {\n      console.error('Error saving favorites to localStorage:', error);\n      throw error;\n    }\n  },\n  /**\n   * Add a favorite game ID\n   * @param {number} gameId - Game ID to add\n   * @returns {string} timestamp of the change\n   */\n  addFavorite(gameId) {\n    const {\n      favorites\n    } = this.getFavorites();\n    if (!favorites.includes(gameId)) {\n      favorites.push(gameId);\n      return this.setFavorites(favorites);\n    }\n    return this.getFavorites().lastModified;\n  },\n  /**\n   * Remove a favorite game ID\n   * @param {number} gameId - Game ID to remove\n   * @returns {string} timestamp of the change\n   */\n  removeFavorite(gameId) {\n    const {\n      favorites\n    } = this.getFavorites();\n    const newFavorites = favorites.filter(id => id !== gameId);\n    if (newFavorites.length !== favorites.length) {\n      return this.setFavorites(newFavorites);\n    }\n    return this.getFavorites().lastModified;\n  },\n  /**\n   * Check if a game is favorited\n   * @param {number} gameId - Game ID to check\n   * @returns {boolean}\n   */\n  isFavorite(gameId) {\n    const {\n      favorites\n    } = this.getFavorites();\n    return favorites.includes(gameId);\n  },\n  /**\n   * Clear all favorites\n   */\n  clearFavorites() {\n    try {\n      localStorage.removeItem(FAVORITES_KEY);\n    } catch (error) {\n      console.error('Error clearing favorites from localStorage:', error);\n    }\n  },\n  /**\n   * Sync favorites with server data based on timestamps\n   * @param {number[]} serverFavorites - Favorites from server\n   * @param {string} serverLastModified - Server's last modified timestamp\n   * @returns {Object} { favorites: number[], source: 'local'|'server'|'merged', timestamp: string }\n   */\n  syncFavorites(serverFavorites, serverLastModified) {\n    const local = this.getFavorites();\n\n    // If no local data, use server data\n    if (!local.lastModified) {\n      if (serverFavorites && serverFavorites.length > 0) {\n        this.setFavorites(serverFavorites);\n        return {\n          favorites: serverFavorites,\n          source: 'server',\n          timestamp: serverLastModified\n        };\n      }\n      return {\n        favorites: local.favorites,\n        source: 'local',\n        timestamp: local.lastModified\n      };\n    }\n\n    // If no server data, keep local data\n    if (!serverLastModified) {\n      return {\n        favorites: local.favorites,\n        source: 'local',\n        timestamp: local.lastModified\n      };\n    }\n\n    // Compare timestamps - most recent wins\n    const localTime = new Date(local.lastModified);\n    const serverTime = new Date(serverLastModified);\n    if (serverTime > localTime) {\n      // Server is newer, update local\n      this.setFavorites(serverFavorites);\n      return {\n        favorites: serverFavorites,\n        source: 'server',\n        timestamp: serverLastModified\n      };\n    } else {\n      // Local is newer or same, keep local\n      return {\n        favorites: local.favorites,\n        source: 'local',\n        timestamp: local.lastModified\n      };\n    }\n  }\n};","map":{"version":3,"names":["FAVORITES_KEY","localStorageService","getFavorites","stored","localStorage","getItem","favorites","lastModified","parsed","JSON","parse","Array","isArray","error","console","setFavorites","data","Date","toISOString","setItem","stringify","addFavorite","gameId","includes","push","removeFavorite","newFavorites","filter","id","length","isFavorite","clearFavorites","removeItem","syncFavorites","serverFavorites","serverLastModified","local","source","timestamp","localTime","serverTime"],"sources":["/Users/dave/Public/5minutegames/client/src/services/localStorageService.js"],"sourcesContent":["/**\n * Local Storage Service for managing user favorites\n * Supports both authenticated and unauthenticated users\n * Uses timestamps for conflict resolution during sync\n */\n\nconst FAVORITES_KEY = 'glg_favorites';\n\nexport const localStorageService = {\n    /**\n     * Get favorites from localStorage\n     * @returns {Object} { favorites: number[], lastModified: string }\n     */\n    getFavorites() {\n        try {\n            const stored = localStorage.getItem(FAVORITES_KEY);\n            if (!stored) {\n                return { favorites: [], lastModified: null };\n            }\n            \n            const parsed = JSON.parse(stored);\n            \n            // Handle legacy format (just array of favorites)\n            if (Array.isArray(parsed)) {\n                return { favorites: parsed, lastModified: null };\n            }\n            \n            // New format with timestamp\n            return {\n                favorites: parsed.favorites || [],\n                lastModified: parsed.lastModified || null\n            };\n        } catch (error) {\n            console.error('Error reading favorites from localStorage:', error);\n            return { favorites: [], lastModified: null };\n        }\n    },\n\n    /**\n     * Set favorites in localStorage with current timestamp\n     * @param {number[]} favorites - Array of game IDs\n     */\n    setFavorites(favorites) {\n        try {\n            const data = {\n                favorites: favorites || [],\n                lastModified: new Date().toISOString()\n            };\n            localStorage.setItem(FAVORITES_KEY, JSON.stringify(data));\n            return data.lastModified;\n        } catch (error) {\n            console.error('Error saving favorites to localStorage:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Add a favorite game ID\n     * @param {number} gameId - Game ID to add\n     * @returns {string} timestamp of the change\n     */\n    addFavorite(gameId) {\n        const { favorites } = this.getFavorites();\n        if (!favorites.includes(gameId)) {\n            favorites.push(gameId);\n            return this.setFavorites(favorites);\n        }\n        return this.getFavorites().lastModified;\n    },\n\n    /**\n     * Remove a favorite game ID\n     * @param {number} gameId - Game ID to remove\n     * @returns {string} timestamp of the change\n     */\n    removeFavorite(gameId) {\n        const { favorites } = this.getFavorites();\n        const newFavorites = favorites.filter(id => id !== gameId);\n        if (newFavorites.length !== favorites.length) {\n            return this.setFavorites(newFavorites);\n        }\n        return this.getFavorites().lastModified;\n    },\n\n    /**\n     * Check if a game is favorited\n     * @param {number} gameId - Game ID to check\n     * @returns {boolean}\n     */\n    isFavorite(gameId) {\n        const { favorites } = this.getFavorites();\n        return favorites.includes(gameId);\n    },\n\n    /**\n     * Clear all favorites\n     */\n    clearFavorites() {\n        try {\n            localStorage.removeItem(FAVORITES_KEY);\n        } catch (error) {\n            console.error('Error clearing favorites from localStorage:', error);\n        }\n    },\n\n    /**\n     * Sync favorites with server data based on timestamps\n     * @param {number[]} serverFavorites - Favorites from server\n     * @param {string} serverLastModified - Server's last modified timestamp\n     * @returns {Object} { favorites: number[], source: 'local'|'server'|'merged', timestamp: string }\n     */\n    syncFavorites(serverFavorites, serverLastModified) {\n        const local = this.getFavorites();\n        \n        // If no local data, use server data\n        if (!local.lastModified) {\n            if (serverFavorites && serverFavorites.length > 0) {\n                this.setFavorites(serverFavorites);\n                return { \n                    favorites: serverFavorites, \n                    source: 'server',\n                    timestamp: serverLastModified \n                };\n            }\n            return { \n                favorites: local.favorites, \n                source: 'local',\n                timestamp: local.lastModified \n            };\n        }\n\n        // If no server data, keep local data\n        if (!serverLastModified) {\n            return { \n                favorites: local.favorites, \n                source: 'local',\n                timestamp: local.lastModified \n            };\n        }\n\n        // Compare timestamps - most recent wins\n        const localTime = new Date(local.lastModified);\n        const serverTime = new Date(serverLastModified);\n\n        if (serverTime > localTime) {\n            // Server is newer, update local\n            this.setFavorites(serverFavorites);\n            return { \n                favorites: serverFavorites, \n                source: 'server',\n                timestamp: serverLastModified \n            };\n        } else {\n            // Local is newer or same, keep local\n            return { \n                favorites: local.favorites, \n                source: 'local',\n                timestamp: local.lastModified \n            };\n        }\n    }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}