{"ast":null,"code":"/**\n * Local Storage Service for managing user favorites\n * Supports both authenticated and unauthenticated users\n * Uses timestamps for conflict resolution during sync\n */\n\nconst FAVORITES_KEY = 'glg_favorites';\nexport const localStorageService = {\n  /**\n   * Get favorites from localStorage\n   * @returns {Object} { favorites: number[], lastModified: string }\n   */\n  getFavorites() {\n    try {\n      const stored = localStorage.getItem(FAVORITES_KEY);\n      if (!stored) {\n        return {\n          favorites: [],\n          lastModified: null\n        };\n      }\n      const parsed = JSON.parse(stored);\n\n      // Handle legacy format (just array of favorites)\n      if (Array.isArray(parsed)) {\n        return {\n          favorites: parsed.map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id)),\n          lastModified: null\n        };\n      }\n\n      // New format with timestamp - ensure IDs are numbers\n      const favorites = (parsed.favorites || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id));\n      return {\n        favorites,\n        lastModified: parsed.lastModified || null\n      };\n    } catch (error) {\n      console.error('Error reading favorites from localStorage:', error);\n      return {\n        favorites: [],\n        lastModified: null\n      };\n    }\n  },\n  /**\n   * Set favorites in localStorage with current timestamp\n   * @param {number[]} favorites - Array of game IDs\n   */\n  setFavorites(favorites) {\n    try {\n      // Ensure all favorites are numbers\n      const numericFavorites = (favorites || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id));\n      const data = {\n        favorites: numericFavorites,\n        lastModified: new Date().toISOString()\n      };\n      localStorage.setItem(FAVORITES_KEY, JSON.stringify(data));\n      return data.lastModified;\n    } catch (error) {\n      console.error('Error saving favorites to localStorage:', error);\n      throw error;\n    }\n  },\n  /**\n   * Add a favorite game ID\n   * @param {number} gameId - Game ID to add\n   * @returns {string} timestamp of the change\n   */\n  addFavorite(gameId) {\n    // Ensure gameId is a number\n    const numericGameId = typeof gameId === 'string' ? parseInt(gameId, 10) : gameId;\n    if (isNaN(numericGameId)) {\n      console.error('Invalid gameId provided to addFavorite:', gameId);\n      return this.getFavorites().lastModified;\n    }\n    const {\n      favorites\n    } = this.getFavorites();\n    if (!favorites.includes(numericGameId)) {\n      favorites.push(numericGameId);\n      return this.setFavorites(favorites);\n    }\n    return this.getFavorites().lastModified;\n  },\n  /**\n   * Remove a favorite game ID\n   * @param {number} gameId - Game ID to remove\n   * @returns {string} timestamp of the change\n   */\n  removeFavorite(gameId) {\n    // Ensure gameId is a number\n    const numericGameId = typeof gameId === 'string' ? parseInt(gameId, 10) : gameId;\n    if (isNaN(numericGameId)) {\n      console.error('Invalid gameId provided to removeFavorite:', gameId);\n      return this.getFavorites().lastModified;\n    }\n    const {\n      favorites\n    } = this.getFavorites();\n    const newFavorites = favorites.filter(id => id !== numericGameId);\n    if (newFavorites.length !== favorites.length) {\n      return this.setFavorites(newFavorites);\n    }\n    return this.getFavorites().lastModified;\n  },\n  /**\n   * Check if a game is favorited\n   * @param {number} gameId - Game ID to check\n   * @returns {boolean}\n   */\n  isFavorite(gameId) {\n    // Ensure gameId is a number\n    const numericGameId = typeof gameId === 'string' ? parseInt(gameId, 10) : gameId;\n    if (isNaN(numericGameId)) {\n      return false;\n    }\n    const {\n      favorites\n    } = this.getFavorites();\n    return favorites.includes(numericGameId);\n  },\n  /**\n   * Clear all favorites\n   */\n  clearFavorites() {\n    try {\n      localStorage.removeItem(FAVORITES_KEY);\n    } catch (error) {\n      console.error('Error clearing favorites from localStorage:', error);\n    }\n  },\n  /**\n   * Sync favorites with server data based on timestamps\n   * @param {number[]} serverFavorites - Favorites from server\n   * @param {string} serverLastModified - Server's last modified timestamp\n   * @returns {Object} { favorites: number[], source: 'local'|'server'|'merged', timestamp: string }\n   */\n  syncFavorites(serverFavorites, serverLastModified) {\n    const local = this.getFavorites();\n\n    // Ensure server favorites are numbers\n    const numericServerFavorites = (serverFavorites || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id));\n\n    // If no local data, use server data\n    if (!local.lastModified) {\n      if (numericServerFavorites.length > 0) {\n        this.setFavorites(numericServerFavorites);\n        return {\n          favorites: numericServerFavorites,\n          source: 'server',\n          timestamp: serverLastModified\n        };\n      }\n      return {\n        favorites: local.favorites,\n        source: 'local',\n        timestamp: local.lastModified\n      };\n    }\n\n    // If no server data, keep local data\n    if (!serverLastModified) {\n      return {\n        favorites: local.favorites,\n        source: 'local',\n        timestamp: local.lastModified\n      };\n    }\n\n    // Compare timestamps - most recent wins\n    const localTime = new Date(local.lastModified);\n    const serverTime = new Date(serverLastModified);\n    if (serverTime > localTime) {\n      // Server is newer, update local\n      this.setFavorites(numericServerFavorites);\n      return {\n        favorites: numericServerFavorites,\n        source: 'server',\n        timestamp: serverLastModified\n      };\n    } else {\n      // Local is newer or same, keep local\n      return {\n        favorites: local.favorites,\n        source: 'local',\n        timestamp: local.lastModified\n      };\n    }\n  }\n};","map":{"version":3,"names":["FAVORITES_KEY","localStorageService","getFavorites","stored","localStorage","getItem","favorites","lastModified","parsed","JSON","parse","Array","isArray","map","id","parseInt","filter","isNaN","error","console","setFavorites","numericFavorites","data","Date","toISOString","setItem","stringify","addFavorite","gameId","numericGameId","includes","push","removeFavorite","newFavorites","length","isFavorite","clearFavorites","removeItem","syncFavorites","serverFavorites","serverLastModified","local","numericServerFavorites","source","timestamp","localTime","serverTime"],"sources":["/Users/dave/Documents/web-games/5-minute-games/src/services/localStorageService.js"],"sourcesContent":["/**\n * Local Storage Service for managing user favorites\n * Supports both authenticated and unauthenticated users\n * Uses timestamps for conflict resolution during sync\n */\n\nconst FAVORITES_KEY = 'glg_favorites';\n\nexport const localStorageService = {\n    /**\n     * Get favorites from localStorage\n     * @returns {Object} { favorites: number[], lastModified: string }\n     */\n    getFavorites() {\n        try {\n            const stored = localStorage.getItem(FAVORITES_KEY);\n            if (!stored) {\n                return { favorites: [], lastModified: null };\n            }\n            \n            const parsed = JSON.parse(stored);\n            \n            // Handle legacy format (just array of favorites)\n            if (Array.isArray(parsed)) {\n                return {\n                    favorites: parsed.map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id)),\n                    lastModified: null\n                };\n            }\n            \n            // New format with timestamp - ensure IDs are numbers\n            const favorites = (parsed.favorites || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id));\n            return {\n                favorites,\n                lastModified: parsed.lastModified || null\n            };\n        } catch (error) {\n            console.error('Error reading favorites from localStorage:', error);\n            return { favorites: [], lastModified: null };\n        }\n    },\n\n    /**\n     * Set favorites in localStorage with current timestamp\n     * @param {number[]} favorites - Array of game IDs\n     */\n    setFavorites(favorites) {\n        try {\n            // Ensure all favorites are numbers\n            const numericFavorites = (favorites || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id));\n            const data = {\n                favorites: numericFavorites,\n                lastModified: new Date().toISOString()\n            };\n            localStorage.setItem(FAVORITES_KEY, JSON.stringify(data));\n            return data.lastModified;\n        } catch (error) {\n            console.error('Error saving favorites to localStorage:', error);\n            throw error;\n        }\n    },\n\n    /**\n     * Add a favorite game ID\n     * @param {number} gameId - Game ID to add\n     * @returns {string} timestamp of the change\n     */\n    addFavorite(gameId) {\n        // Ensure gameId is a number\n        const numericGameId = typeof gameId === 'string' ? parseInt(gameId, 10) : gameId;\n        if (isNaN(numericGameId)) {\n            console.error('Invalid gameId provided to addFavorite:', gameId);\n            return this.getFavorites().lastModified;\n        }\n        \n        const { favorites } = this.getFavorites();\n        if (!favorites.includes(numericGameId)) {\n            favorites.push(numericGameId);\n            return this.setFavorites(favorites);\n        }\n        return this.getFavorites().lastModified;\n    },\n\n    /**\n     * Remove a favorite game ID\n     * @param {number} gameId - Game ID to remove\n     * @returns {string} timestamp of the change\n     */\n    removeFavorite(gameId) {\n        // Ensure gameId is a number\n        const numericGameId = typeof gameId === 'string' ? parseInt(gameId, 10) : gameId;\n        if (isNaN(numericGameId)) {\n            console.error('Invalid gameId provided to removeFavorite:', gameId);\n            return this.getFavorites().lastModified;\n        }\n        \n        const { favorites } = this.getFavorites();\n        const newFavorites = favorites.filter(id => id !== numericGameId);\n        if (newFavorites.length !== favorites.length) {\n            return this.setFavorites(newFavorites);\n        }\n        return this.getFavorites().lastModified;\n    },\n\n    /**\n     * Check if a game is favorited\n     * @param {number} gameId - Game ID to check\n     * @returns {boolean}\n     */\n    isFavorite(gameId) {\n        // Ensure gameId is a number\n        const numericGameId = typeof gameId === 'string' ? parseInt(gameId, 10) : gameId;\n        if (isNaN(numericGameId)) {\n            return false;\n        }\n        \n        const { favorites } = this.getFavorites();\n        return favorites.includes(numericGameId);\n    },\n\n    /**\n     * Clear all favorites\n     */\n    clearFavorites() {\n        try {\n            localStorage.removeItem(FAVORITES_KEY);\n        } catch (error) {\n            console.error('Error clearing favorites from localStorage:', error);\n        }\n    },\n\n    /**\n     * Sync favorites with server data based on timestamps\n     * @param {number[]} serverFavorites - Favorites from server\n     * @param {string} serverLastModified - Server's last modified timestamp\n     * @returns {Object} { favorites: number[], source: 'local'|'server'|'merged', timestamp: string }\n     */\n    syncFavorites(serverFavorites, serverLastModified) {\n        const local = this.getFavorites();\n        \n        // Ensure server favorites are numbers\n        const numericServerFavorites = (serverFavorites || []).map(id => typeof id === 'string' ? parseInt(id, 10) : id).filter(id => !isNaN(id));\n        \n        // If no local data, use server data\n        if (!local.lastModified) {\n            if (numericServerFavorites.length > 0) {\n                this.setFavorites(numericServerFavorites);\n                return {\n                    favorites: numericServerFavorites,\n                    source: 'server',\n                    timestamp: serverLastModified\n                };\n            }\n            return {\n                favorites: local.favorites,\n                source: 'local',\n                timestamp: local.lastModified\n            };\n        }\n\n        // If no server data, keep local data\n        if (!serverLastModified) {\n            return {\n                favorites: local.favorites,\n                source: 'local',\n                timestamp: local.lastModified\n            };\n        }\n\n        // Compare timestamps - most recent wins\n        const localTime = new Date(local.lastModified);\n        const serverTime = new Date(serverLastModified);\n\n        if (serverTime > localTime) {\n            // Server is newer, update local\n            this.setFavorites(numericServerFavorites);\n            return {\n                favorites: numericServerFavorites,\n                source: 'server',\n                timestamp: serverLastModified\n            };\n        } else {\n            // Local is newer or same, keep local\n            return {\n                favorites: local.favorites,\n                source: 'local',\n                timestamp: local.lastModified\n            };\n        }\n    }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}